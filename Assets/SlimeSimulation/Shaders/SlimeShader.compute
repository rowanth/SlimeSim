// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel Update
#pragma kernel ProcessTrailMap

#define PI 3.14159265358979323846

struct Agent {
    float2 position;
    float angle;
};

//Hash Function
uint hash(uint state) {
    state ^= 2747636419u;
    state *= 2654435769u;
    state ^= state >> 16;
    state *= 2654435769u;
    state ^= state >> 16;
    state *= 2654435769u;
    return state;
}

float scaleToRange01(uint val) {
    float delta = 4294967295.0;
    return (val - 0) / delta;
}

RWStructuredBuffer<Agent> agents;
RWTexture2D<float4> TrailMap;

uint width;
uint height;
uint numAgents;
float moveSpeed;
float deltaTime;

[numthreads(16,1,1)]
void Update(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= numAgents) { return; }

    Agent agent = agents[id.x];
    uint random = hash(agent.position.y * width + agent.position.x + hash(id.x));

    //Move agent based on diraction and speed
    float2 direction = float2(cos(agent.angle), sin(agent.angle));
    float2 newPos = agent.position + direction * moveSpeed * deltaTime;

    //Clamp position to map boundaries, and pick new random move angle if hit boundary
    if (newPos.x < 0 || newPos.x >= width || newPos.y < 0 || newPos.y >= height) {
        newPos.x = min(width-0.01, max(0, newPos.x));
        newPos.y = min(height-0.01, max(0, newPos.y));
        agents[id.x].angle = (random / 4294967295.0) * 2 * PI;
    }

    agents[id.x].position = newPos;
    TrailMap[int2(newPos.x, newPos.y)] = 1;
}

RWTexture2D<float4> ProcessedTrailMap;
float evaporateSpeed;

[numthreads(8, 8, 1)]
void ProcessTrailMap(uint3 id : SV_DispatchThreadID)
{
    if (id.x < 0 || id.x >= width || id.y < 0 || id.y >= height) { return; }

    float originalValue = TrailMap[id.xy];
    float evaporatedValue = max(0, originalValue - evaporateSpeed * deltaTime);

    ProcessedTrailMap[id.xy] = evaporatedValue;
}